def savings(output,need,kwp,kwh_price,kwh_compensation):
    '''
    returns costs and effective earnings in € for energy
    :param kwh_compensation: compensation per kWh fed into the grid in €
    :param kwh_price: price pr kwh from the grid
    :param kwp: official installed kWp value
    :param output: output in kWh
    :param need: own consumption in kWh
    '''
    if output>need:
        balance = (output-need)*kwh_compensation/100 + need*kwh_price
    else:
        balance = output*kwh_price
    
    return balance


def optimized_df(
    weather_df,
    opt_index,
    need_df,
    loss_df,
    panel_size_total,
    panel_efficiency,
    loss_technical
):
    '''
    returns a dataframe with loss factors, amount of electricity generated and saved and money saved
    :param weather_df: the raw weather dataframe
    :param index: the index for the optimal rows, should include id_tuple, tilt and alignment
    :param need_df: dataframe with consumption data
    :param loss_df: dataframe with loss data
    '''
    # set up the optimal df
    optimized = (
            weather_df
            .copy()
            .set_index(['id_tuple','tilt','alignment'])
            .loc[opt_index,['date','pm','output_highvar']]
            .groupby(['id_tuple','tilt','alignment','date','pm'])
            # get the sum of the highvar_output for each halfday with the optimal tilt-alignment combination
            .agg('sum')
            # join the need_df and loss_df
            .join(need_df)
            .join(loss_df)
    )

    # compute the total output 
    optimized.loc[:,'output_total'] =[
        output * panel_size_total * panel_efficiency * (1-loss_technical)/1000
        for output
        in optimized.output_highvar
    ]
    return 5


def optimal_combination(
    weather_df,
    opt_index,
    outpul_col,
    *join_dfs
):
    '''
    returns dataframe only with the rows that correspond to the optimal tilt-alignment combination
    :param weather_df: the raw weather dataframe
    :param index: the index for the optimal rows, should include id_tuple, tilt and alignment
    :param join_dfs: dataframe to join to the weather_df, might contain data regarding consumption, loss, area_indicators
    :param loss_df: dataframe with loss data
    '''
    # set up the optimal df
    optimized = (
            weather_df
            .copy()
            .set_index(['id_tuple','tilt','alignment'])
            .loc[opt_index,['date','pm',outpul_col]]
            .groupby(['id_tuple','tilt','alignment','date','pm'])
            # get the sum of the highvar_output for each halfday with the optimal tilt-alignment combination
            .agg('sum')
    )
    for df in join_dfs:
        optimized = optimized.join(df)
    return optimized


def compute_finances(
    df_for_finances,
    kwp,
    kwh_price,
    kwh_compensation,
    output_col = 'output_highvar',
    panel_size_col = 'panel_area',
    need_col = 'need',
    id_col = 'id_tuple'
    ):
    '''
    returns dataframe with added columns regarding finances (total output, grid feed, savings & earnings)
    :param df_for_finances: dataframe to compute finances for
    :param kwp: peak kW value of the installed panels
    :param kwh_price: price of a kWh in €
    :param kwh_compensation: compensation per kWh fed into the grid in euro-cents
    :param output_col: name of the column with out after high variance loss factors
    :param panel_size_col: name of the column with the panel size
    :param need_col: name of the column with electricity need data
    '''
    # make a copy
    df = df_for_finances.reset_index().copy()
    print(df.columns)
    # compute the covered timespan
    timespan = (df['date'].max() - df['date'].min()).days+1

    # compute the total  dailyoutput
    df.loc[:,'output_total'] = [
    output * size/1000
    for output, size
    in zip(
        df[output_col],
        df[panel_size_col]
        )
    ]

    # compute daily grid feed
    df.loc[:,'grid_feed'] = [
    (gen-use)
    for gen, use
    in zip(
        df['output_total'],
        df[need_col]
        )
    ]

    # compute the earnings generated by the feeding into the grid
    df.loc[:,'savings'] = [
        savings(out,need,kwp,kwh_price,kwh_compensation)
        for out, need
        in zip(
            df.output_total,
            df[need_col]
        )
    ]

    # aggregate max_out_df to get the total earnings
    df = (df
        .groupby([id_col])
        .agg({
            **dict.fromkeys(['output_total','grid_feed','savings'],'sum'),
            **dict.fromkeys(['loss_snow', 'loss_temp', 'loss_soiling', 'loss_highvar'],'mean')
        })
    )

    # calculate the daily mean for the col that were added together
    # compute the daily output
    df.loc[:,'output_total_daily'] = [
        x/timespan
        for x
        in df.output_total
    ]
    # daily grid feed
    df.loc[:,'grid_feed_daily'] = [
        x/timespan
        for x
        in df.grid_feed
    ]
    # daily earnings
    df.loc[:,'savings_daily'] = [
        x/timespan
        for x
        in df.savings
    ]

    # drop the now unnecessary cols
    df.drop(['output_total','grid_feed','savings'],inplace=True,axis=1)

    return df

def setup_cost(kwp):
    '''
    returns the estimated cost of the solar panels including installation
    '''
    if kwp < 30:
        cost = -.01431*kwp**2 + 1.37393 * kwp + 1.23509
    else:
        cost = .51527*kwp + 14.12
    return cost

